use std::path::Path;
use std::process::Command;
use crate::gen::generators::client::csharp::gen::CSharpClientGenerator;
use crate::gen::generators::client::csharp::types::CSharpTypes;
use crate::gen::generators::client::dart::gen::DartClientGenerator;
use crate::gen::generators::client::dart::types::DartTypes;
use crate::gen::generators::client::kotlin::gen::KotlinClientGenerator;
use crate::gen::generators::client::kotlin::types::KotlinTypes;
use crate::gen::generators::client::swift::gen::SwiftClientGenerator;
use crate::gen::generators::client::swift::types::SwiftTypes;
use crate::gen::generators::client::typescript::gen::{TsClientGenerator, TsGenerationConf};
use crate::gen::interface::client::conf::ClientConf;
use crate::gen::interface::client::kind::Kind;
use crate::gen::internal::client::ctx::Ctx;
use crate::gen::internal::client::generator::Generator;
use crate::gen::internal::file_util::FileUtil;
use crate::gen::internal::message::green_message;
use crate::prelude::Graph;
use crate::core::result::Result;
use crate::gen::generators::client::typescript::types::TsTypes;

pub(crate) async fn gen(graph: &Graph, conf: &ClientConf) -> Result<()> {
    match conf.kind {
        Kind::TypeScript => generate_client_typed(TsClientGenerator::new(), &Ctx::build(graph, conf, TsTypes::new(TsGenerationConf::client()))).await,
        Kind::Swift => generate_client_typed(SwiftClientGenerator::new(), &Ctx::build(graph, conf, SwiftTypes::new())).await,
        Kind::Kotlin => generate_client_typed(KotlinClientGenerator::new(), &Ctx::build(graph, conf, KotlinTypes::new())).await,
        Kind::CSharp => generate_client_typed(CSharpClientGenerator::new(), &Ctx::build(graph, conf, CSharpTypes::new())).await,
        Kind::Dart => generate_client_typed(DartClientGenerator::new(), &Ctx::build(graph, conf, DartTypes::new())).await,
    }
}

async fn generate_client_typed<T: Generator>(client_generator: T, ctx: &Ctx<'_>) -> Result<()> {
    let dest = &ctx.conf.dest;
    let package = ctx.conf.package;
    let git_commit = ctx.conf.git_commit;
    let mut module_dest = dest.clone();
    let should_git_init = !dest.exists();
    if package {
        let package_generator = FileUtil::new(dest);
        client_generator.generate_package_files(ctx, &package_generator).await?;
        module_dest.push(Path::new(client_generator.module_directory_in_package(ctx.conf).as_str()));
    }
    let module_generator = FileUtil::new(module_dest);
    client_generator.generate_module_files(ctx, &module_generator).await?;
    client_generator.generate_main(ctx, &module_generator).await?;
    if git_commit && package {
        std::env::set_current_dir(dest).unwrap();
        if should_git_init {
            // git init
            Command::new("git")
                .arg("init")
                .output().unwrap();
            green_message("Run", "`git init`".to_string());
        }
        // git add -A
        Command::new("git")
            .arg("add")
            .arg("-A")
            .output().unwrap();
        green_message("Run", "`git add -A`".to_string());
        Command::new("git")
            .arg("commit")
            .arg("-m")
            .arg("generated by teo")
            .output().unwrap();
        // git commit
        green_message("Run", "`git commit -m 'generated by teo'`".to_string());
    }
    Ok(())
}
